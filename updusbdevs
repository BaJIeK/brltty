#!/usr/bin/env tclsh
###############################################################################
# BRLTTY - A background process providing access to the console screen (when in
#          text mode) for a blind person using a refreshable braille display.
#
# Copyright (C) 1995-2012 by The BRLTTY Developers.
#
# BRLTTY comes with ABSOLUTELY NO WARRANTY.
#
# This is free software, placed under the terms of the
# GNU General Public License, as published by the Free Software
# Foundation; either version 2 of the License, or (at your option) any
# later version. Please see the file LICENSE-GPL for details.
#
# Web Page: http://mielke.cc/brltty/
#
# This software is maintained by Dave Mielke <dave@mielke.cc>.
###############################################################################

source [file join [file dirname [info script]] "prologue.tcl"]

proc writeWarning {message {level 0}} {
   upvar #0 optionValues(quiet) quiet

   if {$level > $quiet} {
      writeProgramMessage $message
   }
}

proc writeDriverWarning {message} {
   writeWarning $message 2
}

proc writeSourceWarning {location message} {
   writeDriverWarning "$message: [dict get $location file]\[[dict get $location line]\]"
}

proc makeDecimalNumber {value} {
   return [expr {$value + 0}]
}

proc makeGenericIdentifier {vendor product} {
   return [join [list [makeDecimalNumber $vendor] [makeDecimalNumber $product]] :]
}

proc getMakeProperty {file property} {
   set result ""

   if {[catch [list open $file {RDONLY}] stream] == 0} {
      while {[gets $stream line] >= 0} {
         if {[regexp "^$property\\s*=\\s*(.*?)\\s*\$" $line x value]} {
            set result $value
            break
         }
      }

      close $stream
   } else {
      writeProgramMessage $stream
   }

   return $result
}

proc getDriverProperty {driverDirectory propertyName} {
   return [getMakeProperty [file join $driverDirectory "Makefile.in"] $propertyName]
}

proc getDriverCode {driverDirectory} {
   return [getDriverProperty $driverDirectory DRIVER_CODE]
}

proc parseChannelDefinition {channelVariable lines location} {
   set channel [dict create]
   set ok 1

   foreach line $lines {
      if {[regexp {\{\s*/\*\s*(.*?)\s*\*/\s*$} $line x model]} {
         dict set channel model $model
         continue
      }

      if {[regexp {\.vendor\s*=\s*(\S*?)\s*,} $line x vendor]} {
         dict set channel vendor $vendor
      }

      if {[regexp {\.product\s*=\s*(\S*?)\s*,} $line x vendor]} {
         dict set channel product $vendor
      }
   }

   foreach property {model vendor product} {
      if {![dict exists $channel $property]} {
         writeSourceWarning $location "property not defined: $property"
         set ok 0
      }
   }

   if {$ok} {
      foreach property {vendor product} {
         if {[string is integer -strict [set value [dict get $channel $property]]]} {
            dict set channel $property [makeDecimalNumber $value]
         } else {
            writeSourceWarning $location "$property is not numeric: $value"
            dict unset channel $property
            set ok 0
         }
      }

      if {$ok} {
         uplevel 1 [list set $channelVariable $channel]
         return 1
      }
   }

   return 0
}

proc parseChannelDefinitions {channelsVariable lines location} {
   upvar 1 $channelsVariable channels
   set lineNumber [dict get $location line]

   foreach lineText $lines {
      if {[info exists definition]} {
         if {[regexp {\}} $lineText]} {
            if {[parseChannelDefinition channel $definition $location]} {
               lappend channels $channel
            }

            unset definition
         } else {
            lappend definition $lineText
         }
      } elseif {[regexp {\{} $lineText]} {
         set definition [list $lineText]
         dict set location line $lineNumber
      }

      incr lineNumber
   }
}

proc parseSourceFile {channelsVariable file} {
   upvar 1 $channelsVariable channels

   if {[catch [list open $file {RDONLY}] stream] == 0} {
      set location [dict create]
      dict set location file $file
      set lineNumber 0

      while {[gets $stream lineText] >= 0} {
         incr lineNumber

         if {[info exists definitions]} {
            if {[regexp {\}\s*;} $lineText]} {
               parseChannelDefinitions channels $definitions $location
               unset definitions
            } else {
               lappend definitions $lineText
            }
         } elseif {[regexp {\sconst\s+UsbChannelDefinition\s} $lineText]} {
            set definitions [list]
            dict set location line [expr {$lineNumber + 1}]
         }
      }

      close $stream
   } else {
      writeProgramMessage $stream
   }
}

proc parseSourceFiles {channelsVariable driverDirectory} {
   upvar 1 $channelsVariable channels

   foreach file [glob -directory $driverDirectory -nocomplain {*.[ch]}] {
      parseSourceFile channels $file
   }

   return $channels
}

proc parseDriver {directory} {
   set driver [dict create]
   dict set driver name [set name [file tail $directory]]

   set channels [list]

   if {[string length [set code [getDriverCode $directory]]] > 0} {
      dict set driver code $code
      parseSourceFiles channels $directory
   } else {
      writeDriverWarning "driver code not defined: $name"
   }

   dict set driver channels $channels
   return $driver
}

proc parseDrivers {} {
  global sourceDirectory

  set drivers [list]

  foreach directory [lsort [glob -directory [file join $sourceDirectory Drivers Braille] -types {d r x} -nocomplain *]] {
     if {[llength [dict get [set driver [parseDriver $directory]] channels]] > 0} {
        lappend drivers $driver
     }
  }

  return $drivers
}

proc formatDevice {device} {
   return "[dict get $device name]\[[dict get $device model]\]"
}

proc getGenericIdentifiers {} {
   global genericDevices
   set identifiers [list]

   foreach device $genericDevices {
      lappend identifiers [makeGenericIdentifier [lindex $device 0] [lindex $device 1]]
   }

   return $identifiers
}

proc getVendors {drivers} {
   set genericIdentifiers [getGenericIdentifiers]
   set vendors [dict create]

   foreach driver $drivers {
      dict with driver {
         foreach channel $channels {
            dict with channel {
               set device [dict create code $code name $name model $model]
               set identifier [makeGenericIdentifier $vendor $product]

               if {[lsearch -exact $genericIdentifiers $identifier] >= 0} {
                  writeWarning "generic device: $identifier: [formatDevice $device]" 1
               }

               if {[dict exists $vendors $vendor $product]} {
                  set devices [dict get $vendors $vendor $product]
                  writeWarning "device specified more than once: $identifier: [formatDevice [lindex $devices 0]] & [formatDevice $device]" 1
               } else {
                  set devices [list]
               }

               lappend devices $device
               dict set vendors $vendor $product $devices
            }
         }
      }
   }

   return $vendors
}

proc getSchemes {} {
   set schemes [list]
   set length [string length [set prefix makeLines_]]

   foreach command [info procs $prefix*] {
      lappend schemes [string range $command $length end]
   }

   return $schemes
}

proc parseFileArguments {filesArray schemes arguments} {
   upvar 1 $filesArray files

   foreach argument $arguments {
      if {[set index [string first : $argument]] < 0} {
         syntaxError "scheme not specified: $argument"
      }

      if {[string length [set scheme [string range $argument 0 $index-1]]] == 0} {
         syntaxError "scheme not specified: $argument"
      }

      if {[lsearch -exact $schemes $scheme] < 0} {
         syntaxError "unknown scheme: $scheme"
      }

      if {[string length [set path [string range $argument $index+1 end]]] == 0} {
         syntaxError "path not specified: $argument"
      }

      if {![file exists $path]} {
         semanticError "file not found: $path"
      }

      if {![file isfile $path]} {
         semanticError "not a file: $path"
      }

      if {![file readable $path]} {
         semanticError "file not readable: $path"
      }

      if {![file writable $path]} {
         semanticError "file not writable: $path"
      }

      lappend files($scheme) $path
   }
}

proc makeLines_android {vendor product drivers descriptions} {
   set lines [list]

   foreach description $descriptions {
      lappend lines "<!-- $description -->"
   }

   lappend lines "<usb-device vendor-id=\"$vendor\" product-id=\"$product\" />"
   return $lines
}

proc makeLines_hotplug {vendor product drivers descriptions} {
   set lines [list]

   foreach description $descriptions {
      lappend lines "# $description"
   }

   lappend lines [format "brltty-%s 0x%04x 0x%04x 0x%04x" [join $drivers ","] 3 $vendor $product]
   return $lines
}

proc makeLines_udev {vendor product drivers descriptions} {
   set lines [list]

   foreach description $descriptions {
      lappend lines "# $description"
   }

   lappend lines [format "ENV\{PRODUCT\}==\"%x/%x/*\", ENV\{BRLTTY_DRIVER\}=\"%s\", GOTO=\"brltty_usb_run\"" $vendor $product [join $drivers ","]]
   return $lines
}

proc makeLines_windows {vendor product drivers descriptions} {
   set lines [list]
   lappend lines [format "\"LibUSB: %s\"=LIBUSB_DEV, USB\\VID_%04X&PID_%04X" [join $descriptions ", "] $vendor $product]
   return $lines
}

proc makeLines {linesArray schemes vendors} {
   foreach scheme $schemes {
      upvar 1 ${linesArray}($scheme) lines
      set lines [list ""]

      foreach vendor [lsort -integer [dict keys $vendors]] {
         set products [dict get $vendors $vendor]

         foreach product [lsort -integer [dict keys $products]] {
            set devices [dict get $products $product]

            set codes [list]
            set descriptions [list]

            foreach device $devices {
               dict with device {
                  lappend codes $code
                  lappend descriptions "$name \[$model\]"
               }
            }

            eval [list lappend lines] [makeLines_$scheme $vendor $product [lsort -unique $codes] [lsort $descriptions]]
            lappend lines ""
         }
      }
   }
}

proc readFile {linesVariable file} {
   upvar 1 $linesVariable lines
   set lines [list]

   if {[catch [list open $file {RDONLY}] stream] == 0} {
      while {[gets $stream line] >= 0} {
         lappend lines $line
      }

      close $stream
      return 1
   } else {
      writeProgramMessage $stream
   }

   return 0
}

proc writeFile {lines file} {
   if {[catch [list open $file {WRONLY CREAT TRUNC}] stream] == 0} {
      puts $stream [join $lines \n]
      close $stream
      return 1
   } else {
      writeProgramMessage $stream
   }

   return 0
}

proc updateFile {file newLines} {
   upvar #0 optionValues(test) testMode

   if {[readFile lines $file]} {
      set markerSuffix "_USB_DEVICES"
      set beginMarker "BEGIN$markerSuffix"
      set endMarker "END$markerSuffix"

      set ranges [list]
      set range [list]
      set index 0

      foreach line $lines {
         set location "$file\[[expr {$index + 1}]\]"

         if {[string first $beginMarker $line] >= 0} {
            if {[llength $range] > 0} {
               writeProgramMessage "nested begin marker: $location"
               return 0
            }

            lappend range $index [lindex [regexp -inline -- {^\s*} $line] 0]
         } elseif {[string first $endMarker $line] >= 0} {
            if {[llength $range] == 0} {
               writeProgramMessage "missing begin marker: $location"
               return 0
            }

            lappend range $index
            lappend ranges $range
            set range [list]
         }

         incr index
      }

      if {[llength $range] > 0} {
         writeProgramMessage "missing end marker: $file\[[lindex $range 0]\]"
         return 0
      }

      if {[llength $ranges] == 0} {
         writeProgramMessage "no region(s) found: $file"
         return 0
      }

      set hasChanged 0
      set adjustment 0

      foreach range $ranges {
         set first [expr {[lindex $range 0] + 1 + $adjustment}]
         set prefix [lindex $range 1]
         set last [expr {[lindex $range 2] - 1 + $adjustment}]

         set count [expr {$last - $first + 1}]
         set delta [expr {[llength $newLines] - $count}]
         incr adjustment $delta

         set replacement [list]
         foreach line $newLines {
            if {[string length $line] > 0} {
               set line "$prefix$line"
            }

            lappend replacement "$line"
         }

         if {!$hasChanged} {
            if {$delta != 0} {
               set hasChanged 1
            } else {
               set index 0

               while {$index < $count} {
                  if {[string compare [lindex $lines $first+$index] [lindex $replacement $index]] != 0} {
                     set hasChanged 1
                     break
                  }

                  incr index
               }
            }
         }

         if {$hasChanged} {
            if {$count == 0} {
               set lines [eval [list linsert $lines $first] $replacement]
            } else {
               set lines [eval [list lreplace $lines $first $last] $replacement]
            }
         }
      }

      if {!$hasChanged} {
         return 1
      }

      if {$testMode} {
         writeProgramMessage "test mode - file not updated: $file"
         return 1
      }

      if {[writeFile $lines $file]} {
         writeProgramMessage "file updated: $file"
         return 1
      }
   }

   return 0
}

proc updateFiles {filesArray linesArray} {
   upvar 1 $filesArray files
   upvar 1 $linesArray lines

   foreach scheme [array names files] {
      foreach file $files($scheme) {
         updateFile $file $lines($scheme)
      }
   }
}

set sourceDirectory $programDirectory

set genericDevices {
   {0X0403 0X6001}
   {0X10C4 0XEA60}
   {0X10C4 0XEA80}
}

set optionDefinitions {
   {quiet counter}
   {test  flag}
}

if {![processOptions optionValues argv $optionDefinitions]} {
   syntaxError
}

if {[llength $argv] == 0} {
   lappend argv "android:[file join $sourceDirectory Android Application res xml usb_devices.xml]"
   lappend argv "hotplug:[file join $sourceDirectory Hotplug brltty.usermap]"
   lappend argv "udev:[file join $sourceDirectory Hotplug udev.rules]"
   lappend argv "windows:[file join $sourceDirectory Hotplug brltty.inf]"
   lappend argv "windows:[file join $sourceDirectory Hotplug brltty-libusb-1.0.inf]"
}

if {[llength $argv] == 0} {
   syntaxError "no file(s) specified"
}

set schemes [getSchemes]
parseFileArguments files $schemes $argv
makeLines lines [array names files] [getVendors [parseDrivers]]
updateFiles files lines
exit 0
