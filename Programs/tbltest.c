/*
 * BRLTTY - A background process providing access to the console screen (when in
 *          text mode) for a blind person using a refreshable braille display.
 *
 * Copyright (C) 1995-2008 by The BRLTTY Developers.
 *
 * BRLTTY comes with ABSOLUTELY NO WARRANTY.
 *
 * This is free software, placed under the terms of the
 * GNU General Public License, as published by the Free Software
 * Foundation.  Please see the file COPYING for details.
 *
 * Web Page: http://mielke.cc/brltty/
 *
 * This software is maintained by Dave Mielke <dave@mielke.cc>.
 */

#include "prologue.h"

#include <stdio.h>
#include <string.h>
#include <errno.h>
#include <ctype.h>

#if defined(HAVE_PKG_CURSES)
#define USE_CURSES
#include <curses.h>
#elif defined(HAVE_PKG_NCURSES)
#define USE_CURSES
#include <ncurses.h>
#elif defined(HAVE_PKG_NCURSESW)
#define USE_CURSES
#include <ncursesw/ncurses.h>
#else
#warning curses package either unspecified or unsupported
#define printw printf
#endif /* HAVE_PKG_CURSES */

#include "program.h"
#include "options.h"
#include "misc.h"
#include "brl.h"
#include "charset.h"
#include "tbl.h"
#include "tbl_internal.h"

#define BRLAPI_NO_DEPRECATED
#include "brlapi.h"

static char *opt_characterSet;
static char *opt_inputFormat;
static char *opt_outputFormat;
static int opt_translate;
static char *opt_dataDirectory;
static int opt_edit;

BEGIN_OPTION_TABLE(programOptions)
  { .letter = 'D',
    .word = "data-directory",
    .flags = OPT_Hidden,
    .argument = "file",
    .setting.string = &opt_dataDirectory,
    .defaultSetting = DATA_DIRECTORY,
    .description = "Path to directory for configuration files."
  },

  { .letter = 't',
    .word = "translate",
    .setting.flag = &opt_translate,
    .description = "Translate."
  },

  { .letter = 'i',
    .word = "input-format",
    .argument = "format",
    .setting.string = &opt_inputFormat,
    .description = "Format of input file."
  },

  { .letter = 'o',
    .word = "output-format",
    .argument = "format",
    .setting.string = &opt_outputFormat,
    .description = "Format of output file."
  },

  { .letter = 'c',
    .word = "character-set",
    .argument = "charset",
    .setting.string = &opt_characterSet,
    .description = "8-bit character set to use."
  },

  { .letter = 'e',
    .word = "edit",
    .setting.flag = &opt_edit,
    .description = "Edit table."
  },
END_OPTION_TABLE

static const DotsTable dotsInternal = {
  BRL_DOT1, BRL_DOT2, BRL_DOT3, BRL_DOT4,
  BRL_DOT5, BRL_DOT6, BRL_DOT7, BRL_DOT8
};

static const DotsTable dots12345678 = {
  0X01, 0X02, 0X04, 0X08, 0X10, 0X20, 0X40, 0X80
};

static const DotsTable dots14253678 = {
  0X01, 0X04, 0X10, 0X02, 0X08, 0X20, 0X40, 0X80
};

static unsigned char
mapDots (unsigned char input, const DotsTable from, const DotsTable to) {
  unsigned char output = 0;
  {
    int dot;
    for (dot=0; dot<DOTS_TABLE_SIZE; ++dot) {
      if (input & from[dot]) output |= to[dot];
    }
  }
  return output;
}

static int
readTable_Native (const char *path, FILE *file, TranslationTable table, void *data) {
  return tblLoad_Native(path, file, table,
                        TBL_UNDEFINED | TBL_DUPLICATE | TBL_UNUSED);
}

static int
writeTable_Native (const char *path, FILE *file, const TranslationTable table, void *data) {
  int index;

  if (fprintf(file, "# generated by %s\n", programName) == EOF) goto error;

  {
    const char *charset = getCharset();
    if (charset)
      if (fprintf(file, "# charset: %s\n", charset) == EOF)
        goto error;
  }

  for (index=0; index<TRANSLATION_TABLE_SIZE; ++index) {
    unsigned char cell = table[index];
    if (fprintf(file, "\\X%02X (", index) == EOF) goto error;

#define DOT(dot) if (fputs(((cell & BRL_DOT##dot)? #dot: " "), file) == EOF) goto error
    DOT(1);
    DOT(2);
    DOT(3);
    DOT(4);
    DOT(5);
    DOT(6);
    DOT(7);
    DOT(8);
#undef DOT

    if (fprintf(file, ")\n") == EOF) goto error;
  }
  return 1;

error:
  return 0;
}

static int
readTable_Binary (const char *path, FILE *file, TranslationTable table, void *data) {
  {
    int character;
    for (character=0; character<TRANSLATION_TABLE_SIZE; ++character) {
      int cell = fgetc(file);

      if (cell == EOF) {
        if (ferror(file)) {
          LogPrint(LOG_ERR, "input error: %s: %s", path, strerror(errno));
        } else {
          LogPrint(LOG_ERR, "table too short: %s", path);
        }
        return 0;
      }

      if (data) cell = mapDots(cell, data, dotsInternal);
      table[character] = cell;
    }
  }

  return 1;
}

static int
writeTable_Binary (const char *path, FILE *file, const TranslationTable table, void *data) {
  {
    int character;
    for (character=0; character<TRANSLATION_TABLE_SIZE; ++character) {
      unsigned char cell = table[character];
      if (data) cell = mapDots(cell, dotsInternal, data);
      if (fputc(cell, file) == EOF) {
        LogPrint(LOG_ERR, "output error: %s: %s", path, strerror(errno));
        return 0;
      }
    }
  }

  return 1;
}

#ifdef HAVE_ICONV_H
static int
readTable_Gnome (const char *path, FILE *file, TranslationTable table, void *data) {
  return tblLoad_Gnome(path, file, table,
                       TBL_UNDEFINED | TBL_DUPLICATE | TBL_UNUSED);
}

static int
writeTable_Gnome (const char *path, FILE *file, const TranslationTable table, void *data) {
  int i;

  /* TODO UNKNOWN-CHAR %wc all */
  if (fprintf(file, "ENCODING UTF-8\n") == EOF) goto error;
  if (fprintf(file, "# generated by %s\n", programName) == EOF) goto error;

  for (i=0; i<=0XFF; i++) {
    char c = i;
    wchar_t wc;
    wchar_t pattern = BRL_UC_ROW | table[i];

    if ((wc = convertCharToWchar(c)) == WEOF) continue;
    if (isprint(i) && !isspace(i)) {
      Utf8Buffer utf8C, utf8Pattern;
      if (!convertWcharToUtf8(wc, utf8C)) continue;
      if (!convertWcharToUtf8(pattern, utf8Pattern)) continue;
      if (fprintf(file, "UCS-CHAR %s %s\n", utf8C, utf8Pattern) == EOF) goto error;
    } else {
      uint32_t u32 = pattern;
      if (fprintf(file, "UNICODE-CHAR U+%04x U+%04"PRIx32"\n", i, u32) == EOF) goto error;
    }
  }
  return 1;

error:
  return 0;
}
#endif /* HAVE_ICONV_H */

typedef int TableReader (const char *path, FILE *file, TranslationTable table, void *data);
typedef int TableWriter (const char *path, FILE *file, const TranslationTable table, void *data);
typedef struct {
  const char *name;
  TableReader *read;
  TableWriter *write;
  void *data;
} FormatEntry;
static const FormatEntry formatEntries[] = {
  {"tbl", readTable_Native, writeTable_Native, NULL},
  {"a2b", readTable_Binary, writeTable_Binary, &dots12345678},
  {"sbl", readTable_Binary, writeTable_Binary, &dots14253678},

#ifdef HAVE_ICONV_H
  {"gnb", readTable_Gnome, writeTable_Gnome, NULL},
#endif /* HAVE_ICONV_H */
  {NULL}
};

static const FormatEntry *
findFormatEntry (const char *name) {
  const FormatEntry *format = formatEntries;
  while (format->name) {
    if (strcmp(name, format->name) == 0) return format;
    ++format;
  }
  return NULL;
}

static const char *
findFileExtension (const char *path) {
  const char *name = strrchr(path, '/');
  return strrchr((name? name: path), '.');
}

static const FormatEntry *
getFormatEntry (const char *name, const char *path, const char *description) {
  if (!(name && *name)) {
    name = findFileExtension(path);
    if (!(name && *++name)) {
      LogPrint(LOG_ERR, "unspecified %s format.", description);
      exit(2);
    }
  }

  {
    const FormatEntry *format = findFormatEntry(name);
    if (format) return format;
  }

  LogPrint(LOG_ERR, "unknown %s format: %s", description, name);
  exit(2);
}

static FILE *
openTable (const char **file, const char *mode, const char *directory, FILE *stdStream, const char *stdName) {
  if (stdStream) {
    if (strcmp(*file, "-") == 0) {
      *file = stdName;
      return stdStream;
    }
  }

  if (directory) {
    const char *path = makePath(directory, *file);
    if (!path) return NULL;
    *file = path;
  }

  {
    FILE *stream = fopen(*file, mode);
    if (!stream) LogPrint(LOG_ERR, "table open error: %s: %s", *file, strerror(errno));
    return stream;
  }
}

int
main (int argc, char *argv[]) {
  int status;
  const char *inputPath;
  const char *outputPath;
  const FormatEntry *inputFormat;
  const FormatEntry *outputFormat;

  {
    static const OptionsDescriptor descriptor = {
      OPTION_TABLE(programOptions),
      .applicationName = "tbltest",
      .argumentsSummary = "input-table [output-table]"
    };
    processOptions(&descriptor, &argc, &argv);
  }

  {
    char **const paths[] = {
      &opt_dataDirectory,
      NULL
    };
    fixInstallPaths(paths);
  }

  if (argc == 0) {
    LogPrint(LOG_ERR, "missing input table.");
    exit(2);
  }
  inputPath = *argv++, argc--;

  if (argc > 0) {
    outputPath = *argv++, argc--;
  } else if (opt_outputFormat && *opt_outputFormat) {
    const char *extension = findFileExtension(inputPath);
    int prefix = extension? (extension - inputPath): strlen(inputPath);
    char buffer[prefix + 1 + strlen(opt_outputFormat) + 1];
    snprintf(buffer, sizeof(buffer), "%.*s.%s", prefix, inputPath, opt_outputFormat);
    outputPath = strdupWrapper(buffer);
  } else {
    outputPath = NULL;
  }

  if (argc > 0) {
    LogPrint(LOG_ERR, "too many parameters.");
    exit(2);
  }

  inputFormat = getFormatEntry(opt_inputFormat, inputPath, "input");
  if (outputPath) {
    outputFormat = getFormatEntry(opt_outputFormat, outputPath, "output");
  } else {
    outputFormat = NULL;
  }

  if (opt_characterSet && !setCharset(opt_characterSet)) {
    LogPrint(LOG_ERR, "can't establish character set: %s", opt_characterSet);
    exit(9);
  }

  if (opt_edit) {
    brlapi_fileDescriptor brlapi_fd = brlapi_openConnection(NULL, NULL);
    FILE *inputFile = openTable(&inputPath, "r", opt_dataDirectory, NULL, NULL);
    TranslationTable table;
    unsigned char current = 0;
    unsigned int brlx,brly;

    memset(table, 0xFF, sizeof(table));
    if (inputFile) {
      inputFormat->read(inputPath, inputFile, table, inputFormat->data);
      fclose(inputFile);
    }
#ifdef USE_CURSES
    initscr();
    cbreak();
    noecho();
    nonl();
    intrflush(stdscr, FALSE);
    keypad(stdscr, TRUE);
#endif /* USE_CURSES */
    if (brlapi_fd != (brlapi_fileDescriptor) -1) {
      if (brlapi_enterTtyMode(BRLAPI_TTY_DEFAULT, NULL) != -1) {
	brlapi_getDisplaySize(&brlx, &brly);
      } else {
	brlapi_perror("brlapi_enterTtyMode");
	brlapi_closeConnection();
	brlapi_fd = -1;
      }
    }
    while (1) {
      {
	unsigned char pattern = table[current];
	/* Display current character */
#ifdef USE_CURSES
	clear();
#else /* USE_CURSES */
	printf("\r\n\v");
#endif /* USE_CURSES */
	printw("%2X %3u %lc %lc", current, current, current >= 32 ? convertCharToWchar(current) : ' ', BRL_UC_ROW|pattern);
	printw("\n");
#define DOT(i) (pattern&(1<<((i)-1))?'#':' ')
	printw("%c %c\n",DOT(1),DOT(4));
	printw("%c %c\n",DOT(2),DOT(5));
	printw("%c %c\n",DOT(3),DOT(6));
	printw("%c %c\n",DOT(7),DOT(8));
#ifdef USE_CURSES
	refresh();
#endif /* USE_CURSES */
	if (brlapi_fd != (brlapi_fileDescriptor) -1) {
	  wchar_t text[brlx];
	  brlapi_writeArguments_t args = BRLAPI_WRITEARGUMENTS_INITIALIZER;
	  swprintf(text, brlx, L"%2X %3u %lc %lc%*s", current, current, current >= 32 ? convertCharToWchar(current) : ' ', BRL_UC_ROW|pattern, brlx, "");
	  args.regionBegin = 1;
	  args.regionSize = brlx;
	  args.text = (char*) text;
	  args.textSize = brlx * sizeof(wchar_t);
	  args.charset = "WCHAR_T";
	  brlapi_write(&args);
	}
      }

      {
	/* Wait for input */
	fd_set set;
	int max = STDIN_FILENO + 1;
	FD_ZERO(&set);
	if (brlapi_fd != (brlapi_fileDescriptor) -1) {
	  FD_SET(brlapi_fd, &set);
	  max = brlapi_fd + 1;
	}
	FD_SET(STDIN_FILENO, &set);
	select(max, &set, NULL, NULL, NULL);
        {
          /* Handle input */
	  /* TODO: factorize code */
	  if (FD_ISSET(STDIN_FILENO, &set)) {
	    wint_t wch;
#ifdef USE_CURSES
	    /* FIXME: enter non-blocking mode */
	    int ch = get_wch(&wch);
	    if (ch == KEY_CODE_YES) {
	      switch (wch) {
		case KEY_UP:    current--; break;
		case KEY_DOWN:  current++; break;
		case KEY_PPAGE: current-= 0x10; break;
		case KEY_NPAGE: current+= 0x10; break;
		case KEY_HOME:  current = 0; break;
		case KEY_END:   current = 0xFF; break;
		case KEY_BACKSPACE:
		case KEY_CLEAR:
		case KEY_DC:   table[current] = 0xFF; break;
		case KEY_F(2):
		default: break;
	      }
	    } else if (ch == OK)
#else /* USE_CURSES */
	    wch = getwc(stdin);
#endif /* USE_CURSES */
	    {
	      if (wch >= BRL_UC_ROW && wch <= (BRL_UC_ROW|0xFF)) {
		/* Set braille pattern */
		table[current] = wch & 0xFF;
	      } else if (wch == 'W' - '@') {
		/* ^W: save */
		if (!outputPath)
		  outputPath = inputPath;
		if (!outputFormat)
		  outputFormat = inputFormat;
		FILE *outputFile = openTable(&outputPath, "w", NULL, stdout, "<standard-output>");

		if (outputFile) {
		  outputFormat->write(outputPath, outputFile, table, outputFormat->data);
		  fclose(outputFile);
		}
	      } else if (wch == 'V' - '@') {
		int i;
#ifdef USE_CURSES
		clear();
#endif
		for (i = 0; i < 0x100; i++) {
		  printw("%2X %3u %lc%lc ", i, i, i != 127 && (i&0x7F) >= 32 ? convertCharToWchar(i) : ' ', BRL_UC_ROW|table[i]);
		}
		if (brlapi_fd != (brlapi_fileDescriptor)-1)
		  brlapi_write(NULL);
#ifdef USE_CURSES
		refresh();
		getch();
#else /* USE_CURSES */
		getchar();
#endif /* USE_CURSES */
	      } else {
		/* Switch to char */
		int c = convertWcharToChar(wch);
		if (c != EOF)
		  current = c;
	      }
	    }
	  }
	  if (brlapi_fd != (brlapi_fileDescriptor)-1 && FD_ISSET(brlapi_fd, &set)) {
	    brlapi_keyCode_t key;
	    while (brlapi_readKey(0, &key) == 1) {
	      unsigned long code = key & BRLAPI_KEY_CODE_MASK;
	      switch (key & BRLAPI_KEY_TYPE_MASK) {
		case BRLAPI_KEY_TYPE_CMD:
		  switch (code & BRLAPI_KEY_CMD_BLK_MASK) {
		    case 0:
		      switch (code) {
			case BRLAPI_KEY_CMD_LNUP: current--; break;
			case BRLAPI_KEY_CMD_LNDN: current++; break;
			case BRLAPI_KEY_CMD_PRPGRPH: current -= 0x10; break;
			case BRLAPI_KEY_CMD_NXPGRPH: current += 0x10; break;
			case BRLAPI_KEY_CMD_TOP_LEFT: current = 0; break;
			case BRLAPI_KEY_CMD_BOT_LEFT: current = 0xFF; break;
			default: break;
		      }
		    default: break;
		  }
		  break;
		case BRLAPI_KEY_TYPE_SYM: {
		  /* latin1 */
		  if (code < 0x100) code |= BRLAPI_KEY_SYM_UNICODE;
		  if ((code & 0x1f000000) == BRLAPI_KEY_SYM_UNICODE) {
		    /* unicode */
		    if ((code & 0xffff00) == BRL_UC_ROW) {
		      /* Set braille pattern */
		      table[current] = code & 0xFF;
		    } else {
		      /* Switch to char */
		      int c = convertWcharToChar(code & 0xffffff);
		      if (c != EOF)
			current = c;
		    }
		  } else switch (code) {
		    case BRLAPI_KEY_SYM_BACKSPACE:
		    case BRLAPI_KEY_SYM_DELETE:    table[current] = 0xFF; break;
		    case BRLAPI_KEY_SYM_UP:        current--; break;
		    case BRLAPI_KEY_SYM_DOWN:      current++; break;
		    case BRLAPI_KEY_SYM_PAGE_UP:   current -= 0x10; break;
		    case BRLAPI_KEY_SYM_PAGE_DOWN: current += 0x10; break;
		    case BRLAPI_KEY_SYM_HOME:      current = 0; break;
		    case BRLAPI_KEY_SYM_END:       current = 0xFF; break;
		  }
		  break;
		}
		default:
		  break;
	      }
	    }
	  }
        }
      }
    }
  } else if (opt_translate) {
    FILE *inputFile = openTable(&inputPath, "r", opt_dataDirectory, NULL, NULL);
 
    if (inputFile) {
      TranslationTable inputTable;

      if (inputFormat->read(inputPath, inputFile, inputTable, inputFormat->data)) {
        if (outputPath) {
          FILE *outputFile = openTable(&outputPath, "r", opt_dataDirectory, NULL, NULL);

          if (outputFile) {
            TranslationTable outputTable;

            if (outputFormat->read(outputPath, outputFile, outputTable, outputFormat->data)) {
              TranslationTable table;

              {
                TranslationTable unoutputTable;
                int byte;
                reverseTranslationTable(outputTable, unoutputTable);
                memset(&table, 0, sizeof(table));
                for (byte=TRANSLATION_TABLE_SIZE-1; byte>=0; byte--)
                  table[byte] = unoutputTable[inputTable[byte]];
              }

              status = 0;
              while (1) {
                int character;

                if ((character = fgetc(stdin)) == EOF) {
                  if (ferror(stdin)) {
                    LogPrint(LOG_ERR, "input error: %s", strerror(errno));
                    status = 6;
                  }
                  break;
                }

                if (fputc(table[character], stdout) == EOF) {
                  LogPrint(LOG_ERR, "output error: %s", strerror(errno));
                  status = 7;
                  break;
                }
              }
            } else {
              status = 4;
            }

            if (fclose(outputFile) == EOF) {
              if (!status) {
                LogPrint(LOG_ERR, "output error: %s", strerror(errno));
                status = 7;
              }
            }
          } else {
            status = 3;
          }
        } else {
          LogPrint(LOG_ERR, "output table not specified.");
          status = 2;
        }
      } else {
        status = 4;
      }

      fclose(inputFile);
    } else {
      status = 3;
    }
  } else {
    if (outputFormat != inputFormat) {
      FILE *inputFile = openTable(&inputPath, "r", opt_dataDirectory, stdin, "<standard-input>");

      if (inputFile) {
        TranslationTable table;

        if (inputFormat->read(inputPath, inputFile, table, inputFormat->data)) {
          if (outputPath) {
            FILE *outputFile = openTable(&outputPath, "w", NULL, stdout, "<standard-output>");

            if (outputFile) {
              if (outputFormat->write(outputPath, outputFile, table, outputFormat->data)) {
                status = 0;
              } else {
                status = 6;
              }

              fclose(outputFile);
            } else {
              status = 5;
            }
          } else {
            status = 0;
          }
        } else {
          status = 4;
        }

        fclose(inputFile);
      } else {
        status = 3;
      }
    } else {
      LogPrint(LOG_ERR, "same input and output formats: %s", outputFormat->name);
      status = 2;
    }
  }

  return status;
}
