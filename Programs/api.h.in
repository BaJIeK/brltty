/*
 * libbrlapi - A library providing access to braille terminals for applications.
 *
 * Copyright (C) 2002-2006 by
 *   Samuel Thibault <Samuel.Thibault@ens-lyon.org>
 *   Sébastien Hinderer <Sebastien.Hinderer@ens-lyon.org>
 *
 * libbrlapi comes with ABSOLUTELY NO WARRANTY.
 *
 * This is free software, placed under the terms of the
 * GNU Lesser General Public License, as published by the Free Software
 * Foundation; either version 2.1 of the License,
 * or (at your option) any later version.
 * Please see the file COPYING-API for details.
 *
 * Web Page: http://mielke.cc/brltty/
 *
 * This software is maintained by Dave Mielke <dave@mielke.cc>.
 */

/** \file
 * \brief Types, defines and functions prototypes for \e BrlAPI's library
 */

#ifndef BRLAPI_INCLUDED_API
#define BRLAPI_INCLUDED_API

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

#undef BRLAPI_WIN32

/** \defgroup brlapi_version Version of the BrlAPI library
 * @{ */

/** Library version. */
#undef BRLAPI_RELEASE

/** Library major version. */
#undef BRLAPI_MAJOR

/** Library minor version. */
#undef BRLAPI_MINOR

/** Library revision. */
#undef BRLAPI_REVISION

/** @} */

/* Types are defined there */
#include <sys/types.h>

/* this is for UINT64_MAX */
#include <stdint.h>

/* NULL is defined there */
#include <unistd.h>

/** \defgroup brlapi_handles BrlAPI handles
 *
 * Each function provided by BrlAPI comes in two versions.
 *
 * 1. A version whose name is prefixed by brlapi_ for clients opening only
 * one simultaneous connection with BrlAPI (most frequen case)
 *
 * 2. A version whose name is prefixed by brlapi__ for use by clients
 * wishing to open more than one connection to BrlAPI.
 *
 * A function called brlapi__foo is used in exactly the same way as its
 * brlapi_foo counterpart, except that it takes an additional argument
 * (the first one), which is a handle letting the client refer to a given
 * connection in a similar manner to what file descriptors do.
 * @{ */

/** Type for BrlAPI hanles */
typedef struct brlapi_handle_t brlapi_handle_t;

/** Returns the size of an object of type brlapi_handle_t in bytes */
size_t brlapi_getHandleSize(void);

/** @} */

/** \defgroup brlapi_connection Connecting to BrlAPI
 *
 * Before calling any other function of the library, calling
 * brlapi_openConnection(3) is needed to establish a connection to
 * \e BrlAPI 's server.
 * When the connection is not needed any more, brlapi_closeConnection(3) must be
 * called to close the connection.
 *
 * @{ */

/** Default port number on which connections to \e BrlAPI can be established */
#define BRLAPI_SOCKETPORTNUM 4101 
#define BRLAPI_SOCKETPORT "4101"

/** Maximum packet size for packets exchanged on sockets and with braille
 * terminal */
#define BRLAPI_MAXPACKETSIZE 512

/** Maximum name length for names embeded in BrlAPI packets */
#define BRLAPI_MAXNAMELENGTH 31

/** Default unix path on which connections to \e BrlAPI can be established */
#ifdef BRLAPI_WIN32
#define BRLAPI_SOCKETPATH "\\\\.\\pipe\\BrlAPI"
#else /* BRLAPI_WIN32 */
#define BRLAPI_SOCKETPATH "/var/lib/BrlAPI/"
#endif /* BRLAPI_WIN32 */

/** \e brltty 's settings directory
 *
 * This is where authorization key and driver-dependent key names are found
 * for instance. */
#undef BRLAPI_ETCDIR

/** Default name of the file containing \e BrlAPI 's authorization key
 *
 * This name is relative to BRLAPI_ETCDIR */
#undef BRLAPI_AUTHKEYFILE

/** Default authorization setting */
#define BRLAPI_DEFAUTH BRLAPI_ETCDIR "/" BRLAPI_AUTHKEYFILE

#ifdef BRLAPI_WIN32
#include <windows.h>
typedef HANDLE brlapi_fileDescriptor;
#else
typedef int brlapi_fileDescriptor;
#endif

/** \brief Settings structure for \e BrlAPI connection
 *
 * This structure holds every parameter needed to connect to \e BrlAPI: which
 * file the authorization key can be found in and which computer to connect to.
 *
 * \par Examples:
 * \code
 * brlapi_settings_t settings;
 *
 * settings.auth="/etc/brlapi.key";
 * settings.host="foo";
 * \endcode
 *
 * \e libbrlapi will read authorization key from file \p /etc/brlapi.key
 * and connect to the machine called "foo", on the default TCP port.
 *
 * \code
 * settings.host="10.1.0.2";
 * \endcode
 *
 * lets directly enter an IP address instead of a machine name.
 *
 * \code
 * settings.host=":1";
 * \endcode
 *
 * lets \e libbrlapi connect to the local computer, on port BRLAPI_SOCKETPORTNUM+1
 *
 * \sa brlapi_openConnection(3) brlapi_loadAuthKey(3)
 */
typedef struct {
  /** For security reasons, \e libbrlapi has to get authorized to connect to the
   * \e BrlAPI server. This can be done via a secret key, for instance. This is
   * the path to the file which holds it; it will hence have to be readable by
   * the application.
   *
   * Setting \c NULL defaults it to local installation setup or to the content
   * of the BRLAPI_AUTH environment variable, if it exists. */
  char *auth;

  /** This tells where the \e BrlAPI server resides: it might be listening on
   * another computer, on any TCP port. It should look like "foo:1", which
   * means TCP port number BRLAPI_SOCKETPORTNUM+1 on computer called "foo".
   * \note Please check that resolving this name works before complaining
   *
   * Settings \c NULL defaults it to localhost, using the local installation's
   * default TCP port, or to the content of the BRLAPI_HOST environment
   * variable, if it exists. */
  char *host;
} brlapi_settings_t;

/* BRLAPI_SETTINGS_INITIALIZER */
/** Allows to initialize a structure of type \e brlapi_settings_t *
 * with default values. */
#define BRLAPI_SETTINGS_INITIALIZER { NULL, NULL }

/* brlapi_openConnection */
/** Open a socket and connect it to \e BrlAPI 's server
 *
 * This function first loads an authorization key as specified in settings.
 * It then creates a TCP socket and connects it to the specified machine, on
 * the specified port. It writes the authorization key on the socket and
 * waits for acknowledgement.
 *
 * \return the file descriptor, or -1 on error
 *
 * \note The file descriptor is returned in case the client wants to
 * communicate with the server without using \e libbrlapi functions. If it uses
 * them however, it won't have to pass the file descriptor later, since the
 * library keeps a copy of it. But that also means that
 * brlapi_openConnection(3) may be called several times, but \e libbrlapi
 * functions will always work with the last call's descriptor
 *
 * \par Example:
 * \code
 * if (brlapi_openConnection(&settings,&settings)<0) {
 *  fprintf(stderr,"couldn't connect to BrlAPI at %s: %s\n",
 *   settings.host, brlapi_strerror(&brlapi_error));
 *  exit(1);
 * }
 * \endcode
 *
 * \par Errors:
 * \e BrlAPI might not be on this TCP port, the host name might not be
 * resolvable, the authorization may fail,...
 *
 * \param clientSettings this gives the connection parameters, as described
 * in brlapi_settings_t. If \c NULL, defaults values are used, so that it is
 * generally a good idea to give \c NULL as default, and only fill a
 * brlapi_settings_t structure when the user gave parameters to the program
 * for instance;
 * \param usedSettings if not \c NULL, parameters which were actually used are
 * stored here, if the application ever needs them.
 *
 * \sa
 * brlapi_settings_t
 * brlapi_loadAuthKey(3)
 * brlapi_writePacket(3)
 * brlapi_readPacketHeader(3)
 * brlapi_readPacketContent(3)
 * brlapi_readPacket(3)
 */
brlapi_fileDescriptor brlapi_openConnection(const brlapi_settings_t *clientSettings, brlapi_settings_t *usedSettings);
brlapi_fileDescriptor brlapi__openConnection(brlapi_handle_t *handle, const brlapi_settings_t *clientSettings, brlapi_settings_t *usedSettings);
#define brlapi_initializeConnection(s1, s2) brlapi_openConnection(s1, s2)
#define brlapi__initializeConnection(h, s1, s2) brlapi__openConnection(h, s1, s2)

/* brlapi_closeConnection */
/** Cleanly close the socket
 *
 * This function locks until a closing acknowledgement is received from the
 * server. The socket is then freed, so the file descriptor
 * brlapi_openConnection(3) gave has no meaning any more
 */
void brlapi_closeConnection(void);
void brlapi__closeConnection(brlapi_handle_t *handle);

/* brlapi_expandHost */
/* expands host:port into host & port, returns address family to use */
int brlapi_expandHost(const char *hostAndPort, char **host, char **port);

/* brlapi_loadAuthKey */
/** Load an authorization key from the given file
 *
 * Calling this function shouldn't be needed if brlapi_openConnection(3)
 * is used.
 *
 * \param filename gives the full path of the file;
 * \param authlength gives the size of the \e auth buffer;
 * \param auth is a buffer where the function will store the authorization key.
 *
 * \return 0, -1 on error
 *
 * \sa brlapi_settings_t, brlapi_openConnection */
int brlapi_loadAuthKey(const char *filename, size_t *authlength, void *auth);

/** @} */

/** \defgroup brlapi_info Getting Terminal information
 * \brief How to get information about the connected Terminal
 *
 * Before using Raw mode or key codes, the application should always check the
 * type of the connected terminal, to be sure it is really the one it expects.
 *
 * One should also check for display size, so as to adjust further displaying
 * on it.
 * @{
 */

/* brlapi_getDriverId */
/** Identify the driver used by \e brltty
 *
 * This function will fill its argument with the \e brltty 2-chars code of
 * the driver currently in use, to which it adds a '\\0'.
 *
 * \param id is the buffer given by the application;
 * \param n is the maximum size of the id buffer.
 *
 * \return -1 on error, or a positive value giving the size of the needed
 * buffer, if the supplied one is to small (same as snprintf(3)).
*/
int brlapi_getDriverId(char *id, size_t n);
int brlapi__getDriverId(brlapi_handle_t *handle, char *id, size_t n);

/* brlapi_getDriverName */
/** Return the complete name of the driver used by \e brltty
 *
 * This function fills its argument with the whole name of the braille
 * terminal if available, terminated with a '\\0'.
 *
 * \param name is the buffer given by the application;
 * \param n is the maximum size for the name buffer.
 *
 * \return -1 on error, or a positive value giving the size of the needed
 * buffer, if the supplied one is to small (same as snprintf(3)).
*/
int brlapi_getDriverName(char *name, size_t n);
int brlapi__getDriverName(brlapi_handle_t *handle, char *name, size_t n);

/* brlapi_getDisplaySize */
/** Return the size of the braille display */
int brlapi_getDisplaySize(unsigned int *x, unsigned int *y);
int brlapi__getDisplaySize(brlapi_handle_t *handle, unsigned int *x, unsigned int *y);

/** @} */

/** \defgroup brlapi_tty Tty getting & leaving
 * \brief How to take control of ttys for direct braille display / read
 *
 * Before being able to write on the braille display, the application must tell
 * the server which tty it will handle. Some checking is done just to be sure
 * that only one client gets control of each tty.
 *
 * The application must also specify how braille keys will be delivered to it.
 * Two ways are possible: key codes and commands:
 *
 * - key codes are specific to each braille driver, since the raw key code, as
 *   defined in the driver will be given for each key press.
 *   Using them leads to building highly driver-dependent applications, which
 *   can yet sometimes be useful to mimic existing proprietary applications
 *   for instance.
 * - commands means that applications will get exactly the same values as
 *   \e brltty. This allows driver-independent clients, which will hopefully
 *   be nice to use with a lot of different terminals.
 * \sa brlapi_readKey(3)
 * @{
 */

/* The following macro is for backward compatibility. */
/* It should be removed in the long run. */
#define BRLCOMMANDS NULL

/* brlapi_enterTtyMode */
/** Ask for some tty, with some key mechanism
 *
 * \param tty
 * - If tty>=0, application takes control of the specified tty;
 * - if tty==-1, the library first tries to get the tty number from the WINDOWID
 * environment variable (for xterm case), then the CONTROLVT variable, and at
 * last reads /proc/self/stat (on linux).
 *
 * \param driverName tells how the application wants brlapi_readKey(3) to return
 * key presses. NULL or "" means BRLTTY commands are required,
 * whereas a driver name means that raw key codes returned by this
 * driver are expected.
 *
 * In an X window environment, CONTROLVT might be useful. XFree86 >=4.4 defines
 * an XFree86_VT root window property which exactly holds the used VT, so that
 * it should be given to brlapi_enterTtyMode. If it isn't available, one may,
 * right into .xsession and .xinitrc, grep X's log, for instance:
 *
 * CONTROLVT="$(grep "using VT number" "/var/log/XFree86.$(echo "$DISPLAY" | sed -e "s/^.*::*\([0-9]*\).*$/\1/").log" | sed -e "s/^.*using VT number \([0-9]*\).*$/\1/")"
 *
 * CONTROLVT should also be propagated when running remote applications via ssh,
 * for instance, along with BRLAPI_HOST and the authorization key.
 *
 * \return the used tty number on success, -1 on error
 *
 * \sa brlapi_leaveTtyMode(3) brlapi_readKey(3)
 */
int brlapi_enterTtyMode(int tty, const char *driverName);
#define brlapi_getTty(tty, driverName) brlapi_enterTtyMode(tty, driverName)
int brlapi__enterTtyMode(brlapi_handle_t *handle, int tty, const char *driverName);

/* brlapi_enterTtyModeWithPath */
/** Ask for some tty specified by its path in the tty tree, with some key mechanism
 *
 * \param ttys points on the array of ttys representing the tty path to be got.
 * Can be NULL if nttys is 0.
 * \param nttys gives the number of elements in ttys.
 * \param driverName has the same meaning as in brlapi_enterTtyMode(3)
 *
 * Providing nttys == 0 means to get the root.
 *
 * \sa brlapi_enterTtyMode(3)
 */
int brlapi_enterTtyModeWithPath(int *ttys, int nttys, const char *driverName);
int brlapi__enterTtyModeWithPath(brlapi_handle_t *handle, int *ttys, int nttys, const char *how);
#define brlapi_getTtyPath(ttys, nttys, driverName) brlapi_enterTtyModeWithPath(ttys, nttys, driverName)
#define brlapi__getTtyPath(handle, ttys, nttys, driverName) brlapi__enterTtyModeWithPath(handle, ttys, nttys, driverName)

/* brlapi_leaveTtyMode */
/** Stop controlling the tty
 *
 * \return 0 on success, -1 on error.
 *
 * \sa brlapi_enterTtyMode(3)
 */
int brlapi_leaveTtyMode(void);
#define brlapi_leaveTty brlapi_leaveTtyMode
int brlapi__leaveTtyMode(brlapi_handle_t *handle);

/* brlapi_setFocus */
/** Tell the current tty to brltty
 *
 * This is intended for focus tellers, such as brltty, xbrlapi, screen, ...
 * brlapi_enterTtyMode(3) must have been called beforehand to tell where this focus
 * applies in the tty tree.
 *
 * \return 0 on success, -1 on error.
 *
 * \sa brlapi_enterTtyMode(3) brlapi_leaveTtyMode(3)
 */
int brlapi_setFocus(int tty);
int brlapi__setFocus(brlapi_handle_t *handle, int tty);

/** @} */

/** \defgroup brlapi_write Writing on the braille display
 * \brief Write text to the braille display
 *
 * Once brlapi_enterTtyMode(3) was called, the application can call brlapi_writeText(3)
 * to write things on the braille display.
 *
 * \note Be sure to call brlapi_enterTtyMode(3) \e before calling brlapi_write*(3), or
 * else you'll get an error. This is particularly not always trivial when
 * writing multithreaded applications.
 *
 * \note Dots are coded as described in ISO/TR 11548-1: dot 1 is set iff bit 0
 * is set, dot 2 is set iff bit 1 is set, ... dot \e i+1 is set iff bit \e i is
 * set. This also corresponds to the low-order byte of the coding of unicode's
 * braille row U+2800.
 *
 * @{ */

/* brlapi_writeText */
/** Write the given \\0-terminated string to the braille display
 *
 * If the string is too long, it is cut. If it's too short, spaces are
 * appended.  The current LC_CTYPE locale is considered, unless it is left as
 * default "C", in which case the charset is assumed to be 8bits, and the same
 * as the server's.
 *
 * \param cursor gives the cursor position; if equal to 0, no cursor is shown at
 * all; if cursor==-1, the cursor is left where it is
 *
 * \param str points to the string to be displayed.
 *
 * \return 0 on success, -1 on error.
 */
int brlapi_writeText(int cursor, const char *str);
int brlapi__writeText(brlapi_handle_t *handle, int cursor, const char *str);

/* brlapi_writeDots */
/** Write the given dots array to the display
 *
 * \param dots points on an array of dot information, one per character. Its
 * size must hence be the same as what brlapi_getDisplaySize(3) returns.
 *
 * \return 0 on success, -1 on error.
 */
int brlapi_writeDots(const unsigned char *dots);
int brlapi__writeDots(brlapi_handle_t *handle, const unsigned char *dots);

/* brlapi_writeStruct */
/** Structure containing arguments to be given to brlapi_write(3) */
typedef struct {
  int displayNumber /** Display number -1 == unspecified */;
  unsigned int regionBegin /** Region of display to update, 1st character of display is 1 */;
  unsigned int regionSize /** Number of caracters held in text, attrAnd and attrOr. */;
  char *text /** Text to display, must hold as many characters as the region fields expresses. */;
  unsigned char *attrAnd /** And attributes; applied first */;
  unsigned char *attrOr /** Or attributes; applied \e after ANDing */;
  int cursor /** -1 == don't touch, 0 == turn off, 1 = 1st char of display, ... */;
  char *charset /** Text charset. NULL means it is assumed to be 8bits, and the same as the server's. "" means current locale's charset. If no locale was selected, defaults to NULL's meaning. */;
} brlapi_writeStruct;

/* BRLAPI_WRITESTRUCT_INITIALIZER */
/** Allows to initialize a structure of type \e brlapi_writeStruct *
 * with default values:
 * displayNumber = -1; (unspecified)
 * regionBegin = regionSize = 0; (update the whole display, DEPRECATED and will
 * be forbidden in next release. You must always express the region you wish to
 * update)
 * text = attrAnd = attrOr = NULL; (no text, no attribute)
 * cursor = -1; (don't touch cursor)
*/
#define BRLAPI_WRITESTRUCT_INITIALIZER \
  { -1, 0, 0, NULL, NULL, NULL, -1, NULL }

/* brlapi_write */
/** Update a specific region of the braille display and apply and/or masks
 *
 * \param s gives information necessary for the update
 *
 * regionBegin and regionSize must be filled for specifying which part of the
 * display will be updated.
 *
 * If given, the "text" field holds the text that will be displayed in the
 * region.  The char string must hold exactly as many characters as the region
 * fields express.  For multibyte text, this is the number of \e multibyte
 * caracters.  Notably, combining and double-width caracters count for 1.  The
 * actual length of the text in \e bytes will be computed thanks to strlen(3), so
 * "text" must be null-terminated.
 *
 * The "attrAnd" and "attrOr" masks, if present, are then applied on top of the
 * text.  This hence permits the superimposing of attributes over the text.
 *
 * The "charset" field, if present, specifies the charset of the "text" field.
 * Else, the 8-bit charset of the server is assumed.
 *
 * A special invocation is with an unmodified initialized structure: this clears
 * the client's whole display, letting the display of other applications on
 * the same tty or of applications "under" the tty appear. See Concurrency
 * management section of the BrlAPI documentation for more details.
 *
 * \return 0 on success, -1 on error.
 */
int brlapi_write(const brlapi_writeStruct *s);
int brlapi__write(brlapi_handle_t *handle, const brlapi_writeStruct *s);

/** @} */

/** \defgroup brlapi_keys Reading key presses
 * \brief How to read key presses from the braille terminal
 *
 * Once brlapi_enterTtyMode(3) is called, the application can call brlapi_readKey(3) to
 * read key presses. Either key codes or commands will be returned, depending
 * on parameters given to brlapi_enterTtyMode(3).
 *
 * Key presses are buffered, so that calling brlapi_readKey(3) in non-blocking
 * mode from times to times should suffice.
 *
 * @{
 */

/** Type for key codes
 *
 * Its size is 64 bits, so driver implementors have a whole 64 bit space.
 *
 * Commands split the 64 bit space into 3 parts:
 * - bits 63-32: flags, bits 39-32 are standard X modifiers ;
 * - bits 31-29: key type: 1 for braille commands, 0 for X keysyms ;
 * - bits 28-0:  key code, depending on the key type.
 */
typedef uint64_t brl_keycode_t;

/** Hex print format for brl_keycode_t */
#define BRLAPI_PRIxKEYCODE PRIx64
/** Unsigned print format for brl_keycode_t */
#define BRLAPI_PRIuKEYCODE PRIu64

/** Brl_keycode_t's biggest value
 *
 * As defined in \c <stdint.h> */
#define BRLAPI_KEYCODE_MAX ((brl_keycode_t) (UINT64_MAX))
/* Old name, deprecated.  */
#define BRL_KEYCODE_MAX ((brl_keycode_t) (UINT64_MAX))

/**
 * Mask for flags of brl_keycode_t
 */
#define BRLAPI_KEY_FLAGS_MASK		0xFFFFFFFF00000000ULL
/** Shift for flags of brl_keycode_t */
#define BRLAPI_KEY_FLAGS_SHIFT		32

#define BRLAPI_KEY_FLG(v)		((brl_keycode_t)(v) << BRLAPI_KEY_FLAGS_SHIFT)
/** Standard X modifiers */
/** Mod1 modifier (AKA meta) */
#define BRLAPI_KEY_FLG_MOD1		BRLAPI_KEY_FLG(0x00000008)
/** Mod2 modifier (usually numlock) */
#define BRLAPI_KEY_FLG_MOD2		BRLAPI_KEY_FLG(0x00000010)
/** Mod3 modifier */
#define BRLAPI_KEY_FLG_MOD3		BRLAPI_KEY_FLG(0x00000020)
/** Mod4 modifier */
#define BRLAPI_KEY_FLG_MOD4		BRLAPI_KEY_FLG(0x00000040)
/** Mod5 modifier (usually Alt-Gr) */
#define BRLAPI_KEY_FLG_MOD5		BRLAPI_KEY_FLG(0x00000080)


/**
 * Mask for type of brl_keycode_t
 */
#define BRLAPI_KEY_TYPE_MASK		0x00000000E0000000ULL
/** Shift for type of brl_keycode_t */
#define BRLAPI_KEY_TYPE_SHIFT		29
/** Braille command brl_keycode_t */
#define BRLAPI_KEY_TYPE_CMD		0x0000000020000000ULL
/** X Keysym brl_keycode_t */
#define BRLAPI_KEY_TYPE_SYM		0x0000000000000000ULL

/**
 * Mask for code of brl_keycode_t
 */
#define BRLAPI_KEY_CODE_MASK		0x000000001FFFFFFFULL
/** Shift for code of brl_keycode_t */
#define BRLAPI_KEY_CODE_SHIFT		0

#define BRLAPI_KEY_CMD(v)		(BRLAPI_KEY_TYPE_CMD|((v) << 16))
/** Mask for braille command type */
#define BRLAPI_KEY_CMD_BLK_MASK		0X1FFF0000ULL
/** Mask for braille command value */
#define BRLAPI_KEY_CMD_ARG_MASK		0X0000FFFFULL

/** Standard X keysyms */
#define BRLAPI_KEY_SYM_BACKSPACE	0x0000FF08ULL
#define BRLAPI_KEY_SYM_TAB		0x0000FF09ULL
#define BRLAPI_KEY_SYM_LINEFEED		0x0000FF0DULL
#define BRLAPI_KEY_SYM_ESCAPE		0x0000FF1BULL
#define BRLAPI_KEY_SYM_HOME		0x0000FF50ULL
#define BRLAPI_KEY_SYM_LEFT		0x0000FF51ULL
#define BRLAPI_KEY_SYM_UP		0x0000FF52ULL
#define BRLAPI_KEY_SYM_RIGHT		0x0000FF53ULL
#define BRLAPI_KEY_SYM_DOWN		0x0000FF54ULL
#define BRLAPI_KEY_SYM_PAGE_UP		0x0000FF55ULL
#define BRLAPI_KEY_SYM_PAGE_DOWN	0x0000FF56ULL
#define BRLAPI_KEY_SYM_END		0x0000FF57ULL
#define BRLAPI_KEY_SYM_INSERT		0x0000FF63ULL
#define BRLAPI_KEY_SYM_FUNCTION		0x0000FFBEULL
#define BRLAPI_KEY_SYM_DELETE		0x0000FFFFULL
#define BRLAPI_KEY_SYM_UC		0x01000000ULL

#include "api_constants.h"

/* brlapi_expandKeyCode */
/** Expand a keycode into command, argument and flags parts
 *
 * This function returns one key press's code.
 *
 * \param keyCode is the keycode to be expanded ;
 * \param command points to the integer that will receive the command part ;
 * \param argument points to the integer that will receive the argument part ;
 * \param flags points to the integer that will receive the flags part
 *
 * \return 0 on success, -1 on error.
 */
extern int brlapi_expandKeyCode (
  brl_keycode_t keyCode,
  unsigned int *command,
  unsigned int *argument,
  unsigned int *flags
);

extern const char *brlapi_getKeyName (unsigned int command, unsigned int argument);

extern unsigned char brlapi_dotNumberToBit (unsigned char number);
extern unsigned char brlapi_dotBitToNumber (unsigned char bit);

/** Unicode braille row */
#define BRLAPI_UC_ROW	0x2800UL

/** Maximum keyset size, i.e. maximum number of keys
 * allowed in a key set
 */
#define BRLAPI_MAXKEYSETSIZE (BRLAPI_MAXPACKETSIZE / sizeof(brl_keycode_t))

/* brlapi_readKey */
/** Read a key from the braille keyboard
 *
 * This function returns one key press's code.
 *
 * If NULL or "" was given to brlapi_enterTtyMode(3), a \e brltty command is returned,
 * as described in \c <brltty/brldefs.h> . It is hence pretty
 * driver-independent, and should be used by default when no other option is
 * possible.
 *
 * By default, all commands but those which restart drivers and switch
 * virtual terminals are returned to the application and not to brltty.
 * If the application doesn't want to see some command events,
 * it should call either brlapi_ignoreKeySet(3) or brlapi_ignoreKeyRange(3)
 *
 * If some driver name was given to brlapi_enterTtyMode(3), a raw keycode is returned,
 * as specified by the terminal driver, usually in <brltty/brldefs-xy> where xy
 * is the driver's code. It generally corresponds to the very code that the
 * terminal tells to the driver.
 * This should only be used by applications which are dedicated to a particular
 * braille terminal. Hence, checking the terminal type thanks to a call to
 * brlapi_getDriverId(3) or even brlapi_getDriverName(3) before getting tty
 * control is a pretty good idea.
 *
 * By default, all the keypresses will be passed to the client, none will go
 * through brltty, so the application will have to handle console switching
 * itself for instance.
 *
 * \param block tells whether the call should block until a key is pressed (1)
 *  or should only probe key presses (0);
 * \param code holds the key code if a key press is indeed read.
 *
 * \return -1 on error or signal interrupt and *code is then undefined, 0 if
 * block was 0 and no key was pressed so far, or 1 and *code holds the key code.
 */
int brlapi_readKey(int block, brl_keycode_t *code);
int brlapi__readKey(brlapi_handle_t *handle, int block, brl_keycode_t *code);

/* brlapi_ignoreKeyRange */
/** Ignore some key presses from the braille keyboard
 *
 * This function asks the server to give keys between x and y to \e brltty,
 * rather than returning them to the application via
 * brlapi_readKey(3)
 *
 * \note The given codes are either raw keycodes if some driver name was given
 * to brlapi_enterTtyMode(3), or \e brltty commands if NULL or "" was given. */
int brlapi_ignoreKeyRange(brl_keycode_t x, brl_keycode_t y);
int brlapi__ignoreKeyRange(brlapi_handle_t *handle, brl_keycode_t x, brl_keycode_t y);

/* brlapi_ignoreKeySet */
/** Ignore some key presses from the braille keyboard
 *
 * This function asks the server to give the n keys in set s to \e brltty,
 * rather than returning them to the application via
 * brlapi_readKey(3)
 *
 * \note The given codes are either raw keycodes if some driver name was given
 * to brlapi_enterTtyMode(3), or \e brltty commands if NULL or "" was given. */
int brlapi_ignoreKeySet(const brl_keycode_t *s, unsigned int n);
int brlapi__ignoreKeySet(brlapi_handle_t *handle, const brl_keycode_t *s, unsigned int n);

/* brlapi_acceptKeyRange */
/** Accept some key presses from the braille keyboard
 *
 * This function asks the server to return keys between x and y to the
 * application, and not give them to \e brltty.
 *
 * \note You shouldn't ask the server to give you key presses which are usually
 * used to switch between TTYs, unless you really know what you are doing!
 *
 * \note The given codes are either raw keycodes if some driver name was given
 * to brlapi_enterTtyMode(3), or \e brltty commands if NULL or "" was given. */
int brlapi_acceptKeyRange(brl_keycode_t x, brl_keycode_t y);
int brlapi__acceptKeyRange(brlapi_handle_t *handle, brl_keycode_t x, brl_keycode_t y);
#define brlapi_unignoreKeyRange(x, y) brlapi_acceptKeyRange(x, y)
#define brlapi__unignoreKeyRange(h, x, y) brlapi__acceptKeyRange(h, x, y)
/* brlapi_acceptKeySet */
/** Accept some key presses from the braille keyboard
 *
 * This function asks the server to return all n keys in set s to the
 * application, and not give them to \e brltty.
 *
 * \note You shouldn't ask the server to give you key presses which are usually
 * used to switch between TTYs, unless you really know what you are doing!
 *
 * \note The given codes are either raw keycodes if some driver name was given
 * to brlapi_enterTtyMode(3), or \e brltty commands if NULL or "" was given. */
int brlapi_acceptKeySet(const brl_keycode_t *s, unsigned int n);
int brlapi__acceptKeySet(brlapi_handle_t *handle, const brl_keycode_t *s, unsigned int n);
#define brlapi_unignoreKeySet(s, n) brlapi_acceptKeySet(s, n)
#define brlapi__unignoreKeySet(h, s, n) brlapi__acceptKeySet(h, s, n)
/** @} */

/** \defgroup brlapi_driverspecific Driver-Specific modes
 * \brief Raw and Suspend Modes mechanism
 *
 * If the application wants to directly talk to the braille terminal, it should
 * use Raw Mode. In this special mode, the driver gives the whole control of the
 * terminal to it: \e brltty doesn't work any more.
 *
 * For this, it simply has to call brlapi_enterRawMode(3), then brlapi_sendRaw(3)
 * and brlapi_recvRaw(3), and finally give control back thanks to
 * brlapi_leaveRawMode(3).
 *
 * Special care of the terminal should be taken, since one might completely
 * trash the terminal's data, or even lock it! The application should always
 * check for terminal's type thanks to brlapi_getDriverId(3).
 *
 * The client can also make brltty close the driver by using brlapi_suspendDriver(3),
 * and resume it again with brlapi_resumeDriver(3).  This should not be used if
 * possible: raw mode should be sufficient for any use.  If not, please ask for
 * features :)
 *
 * @{
 */

/* brlapi_enterRawMode */
/** Switch to Raw mode
 * \param driverName Specifies the name of the driver for which the raw
 * communication will be established.
 * \return 0 on success, -1 on error */
int brlapi_enterRawMode(const char *driverName);
#define brlapi_getRaw(driverName) brlapi_enterRawMode(driverName) 
int brlapi__enterRawMode(brlapi_handle_t *handle, const char *driver);

/* brlapi_leaveRawMode */
/** Leave Raw mode
 * \return 0 on success, -1 on error */
int brlapi_leaveRawMode(void);
#define brlapi_leaveRaw brlapi_leaveRawMode
int brlapi__leaveRawMode(brlapi_handle_t *handle);

/* brlapi_sendRaw */
/** Send Raw data
 *
 * \param buf points on the data;
 * \param size holds the packet size.
 * \return size on success, -1 on error */
ssize_t brlapi_sendRaw(const void *buf, size_t size);
ssize_t brlapi__sendRaw(brlapi_handle_t *handle, const void *buf, size_t size);

/* brlapi_recvRaw */
/** Get Raw data
 *
 * \param buf points on a buffer where the function will store the received
 * data;
 * \param size holds the buffer size.
 * \return its size, -1 on error or signal interruption */
ssize_t brlapi_recvRaw(void *buf, size_t size);
ssize_t brlapi__recvRaw(brlapi_handle_t *handle, void *buf, size_t size);

/* brlapi_suspendDriver */
/** Suspend braille driver
 * \param driver Specifies the name of the driver which will be suspended.
 * \return -1 on error
 */
int brlapi_suspendDriver(const char *driver);
int brlapi__suspendDriver(brlapi_handle_t *handle, const char *driver);
#define brlapi_suspend(n) brlapi_suspendDriver(n)
#define brlapi__suspend(h, n) brlapi__suspendDriver(h, n)

/* brlapi_resumeDriver */
/** Resume braille driver
 * \return -1 on error
 */
int brlapi_resumeDriver(void);
int brlapi__resumeDriver(brlapi_handle_t *handle);
#define brlapi_resume brlapi_resumeDriver
#define brlapi__resume(h) brlapi__resumeDriver(h)
/** @} */

/** \defgroup brlapi_error Error handling
 * \brief How to handle errors which might very well happen
 *
 * When a function fails for some normal error, brlapi_errno will hold an error
 * code to explain why it failed. It is good practice to print it somewhere for
 * the user or the programmer to understand why it failed.
 *
 * When something really wrong was done somewhere, like an out-of-bounds
 * argument, which is really a bug in either the implementation of BrlAPI or
 * in the application, an exception may be sent by the server. As soon as
 * libbrlapi receives it, an exception handler prints it and \e abort(3)s 
 * he program, since it means something went really wrong and that we shouldn't
 * go further.
 *
 * This is hopefully a really seldom event, but in the case of an editor, for
 * instance, one would surely want to have files saved before actually
 * abort(3)ing. brlapi_setExceptionHandler(3) lets the programmer define another
 * exception handler which would save files and then call the default handler
 * brlapi_defaultExceptionHandler(3).
 *
 * @{ */

/* Error codes */
#define BRLERR_SUCCESS                  0  /**< Success */
#define BRLERR_NOMEM                    1  /**< Not enough memory */
#define BRLERR_TTYBUSY                  2  /**< A connection is already running in this tty */
#define BRLERR_DEVICEBUSY               3  /**< A connection is already using RAW or suspend mode */
#define BRLERR_UNKNOWN_INSTRUCTION      4  /**< Not implemented in protocol */
#define BRLERR_ILLEGAL_INSTRUCTION      5  /**< Forbiden in current mode */
#define BRLERR_INVALID_PARAMETER        6  /**< Out of range or have no sense */
#define BRLERR_INVALID_PACKET           7  /**< Invalid size */
#define BRLERR_CONNREFUSED              8  /**< Connection refused */
#define BRLERR_OPNOTSUPP                9  /**< Operation not supported */
#define BRLERR_GAIERR                  10  /**< Getaddrinfo error */
#define BRLERR_LIBCERR                 11  /**< Libc error */
#define BRLERR_UNKNOWNTTY              12  /**< Couldn't find out the tty number */
#define BRLERR_PROTOCOL_VERSION        13  /**< Bad protocol version */
#define BRLERR_EOF                     14  /**< Unexpected end of file */
#define BRLERR_EMPTYKEY                15  /**< Key file empty */
#define BRLERR_DRIVERERROR             16  /**< Packet returned by driver too large */

/* brlapi_errlist */
/** Error message list
 *
 * These are the string constants used by brlapi_perror(3).
 */
extern const char *brlapi_errlist[];

/* brlapi_nerr */
/** Number of error messages */
extern const int brlapi_nerr;

/* brlapi_perror */
/** Print a BrlAPI error message
 *
 * brlapi_perror(3) reads brlapi_error, and acts just like perror(3).
 */
void brlapi_perror(const char *s);

/* brlapi_error_t */
/** All information that is needed to describe brlapi errors */
typedef struct {
  int brlerrno;
  int libcerrno;
  int gaierrno;
  const char *errfun;
} brlapi_error_t;

/** Get per-thread error location
 *
 * In multithreaded software, brlapi_error is thread-specific, so api.h
 * cheats about the brlapi_error token and actually calls
 * brlapi_error_location(3).
 *
 * This gets the thread specific location of global variable brlapi_error
 */
brlapi_error_t *brlapi_error_location(void);

/** Global variable brlapi_error
 *
 * brlapi_error is a global left-value containing the last error information.
 * Its errno field is not reset to BRLERR_SUCCESS on success.
 *
 * This information may be copied in brlapi_error_t variables for later use
 * with the brlapi_strerror function.
 */
extern brlapi_error_t brlapi_error;

/** Shorthand for brlapi_error.errno */
extern int brlapi_errno;
/** Shorthand for brlapi_error.libcerrno */
extern int brlapi_libcerrno;
/** Shorthand for brlapi_error.gaierrno */
extern int brlapi_gaierrno;
/** Shorthand for brlapi_error.errfun */
extern const char *brlapi_errfun;

/** Cheat about the brlapi_error C token */
#define brlapi_error (*brlapi_error_location())
/** Cheat about the brlapi_errno C token */
#define brlapi_errno (brlapi_error.brlerrno)
/** Cheat about the brlapi_libcerrno C token */
#define brlapi_libcerrno (brlapi_error.libcerrno)
/** Cheat about the brlapi_gaierrno C token */
#define brlapi_gaierrno (brlapi_error.gaierrno)
/** Cheat about the brlapi_errfun C token */
#define brlapi_errfun (brlapi_error.errfun)

/* brlapi_strerror */
/** Get plain error message
 *
 * brlapi_strerror(3) returns the plain error message corresponding to its
 * argument.
 */
const char *brlapi_strerror(const brlapi_error_t *error);

/** Type for packet type. Only unsigned can cross networks, 32bits */
typedef uint32_t brl_type_t;

/* brlapi_packetType */
/** Get plain packet type
 *
 * brlapi_packetType(3) returns the plain packet type name corresponding to
 * its argument.
 */
const char *brlapi_packetType(brl_type_t ptype);

/* brlapi_exceptionHandler_t */
/** Type for error handlers
 *
 * Type of error handlers which are to be given to
 * brlapi_setExceptionHandler(333).
 *
 * \param err is a BRLERR_ error code;
 * \param type is the type of the guilty packet;
 * \param buf points to the content of the guilty packet (might be a little bit truncated);
 * \param size gives the guilty packet's size.
 */
typedef void (*brlapi_exceptionHandler_t)(int err, brl_type_t type, const void *buf, size_t size);

/* brlapi_strexception */
/** Describes an exception
 *
 * brlapi_strexception(3) puts a text describing the given exception in buf.
 *
 * The beginning of the guilty packet is dumped as a sequence of hex bytes.
 *
 * \return the size of the text describing the exception, following
 * snprintf(3)'s semantics.
*/
int brlapi_strexception(char *buf, size_t n, int err, brl_type_t type, const void *packet, size_t
size);

/* brlapi_setExceptionHandler */
/** Set a new exception handler
 *
 * brlapi_setExceptionHandler(3) replaces the previous exception handler with the handler
 * parameter. The previous exception handler is returned to make chaining error
 * handlers possible.
 *
 * The default handler just prints the exception and exit(3)s.
 */
brlapi_exceptionHandler_t brlapi_setExceptionHandler(brlapi_exceptionHandler_t handler);
brlapi_exceptionHandler_t brlapi__setExceptionHandler(brlapi_handle_t *handle, brlapi_exceptionHandler_t handler);
void brlapi_defaultExceptionHandler(int err, brl_type_t type, const void *buf, size_t size);

/** @} */

/* Windows-specific tricks - don't look at this */
#ifdef BRLAPI_WIN32
int brlapi_writeTextWin(int cursor, const void *str, int wide);
int brlapi__writeTextWin(brlapi_handle_t *handle, int cursor, const void *str, int wide);
int brlapi_writeWin(const brlapi_writeStruct *s, int wide);
int brlapi__writeWin(brlapi_handle_t *handle, const brlapi_writeStruct *s, int wide);
#ifdef UNICODE
#define brlapi_writeText(cursor, str) brlapi_writeTextWin(cursor, str, 1)
#define brlapi__writeText(handle, cursor, str) brlapi__writeTextWin(handle, cursor, str, 1)
#define brlapi_write(s) brlapi_writeWin(s, 1)
#define brlapi__write(handle, s) brlapi__writeWin(handle, s, 1)
#else /* UNICODE */
#define brlapi_writeText(cursor, str) brlapi_writeTextWin(cursor, str, 0)
#define brlapi__writeText(handle, cursor, str) brlapi__writeTextWin(handle, cursor, str, 0)
#define brlapi_write(s) brlapi_writeWin(s, 0)
#define brlapi__write(handle, s) brlapi__writeWin(handle, s, 0)
#endif /* UNICODE */
#endif /* BRLAPI_WIN32 */

#ifdef __cplusplus
}
#endif /* __cplusplus */

#endif /* BRLAPI_INCLUDED_API */
