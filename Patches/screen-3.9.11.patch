--- Makefile.in.orig	Thu Feb 14 14:36:33 2002
+++ Makefile.in	Wed Mar 20 18:28:36 2002
@@ -46,7 +46,12 @@
 # -DDUMPSHADOW
 #	With shadow-pw screen would never dump core. Use this option if
 #	you still want to have a core. Use only for debugging.
-OPTIONS=
+# -DIPC_EXPORT_IMAGE
+#	Allows an other program to get the screen contetn through shared mem 
+#	 and ipc. This is used e.g. for braille and speech software.
+
+OPTIONS=-DIPC_EXPORT_IMAGE
+#OPTIONS=
 #OPTIONS= -DDEBUG
 
 SHELL=/bin/sh


--- extern.h.orig	Tue Feb  5 19:12:41 2002
+++ extern.h	Wed Mar 20 18:28:36 2002
@@ -133,6 +133,11 @@
 extern void  FreePseudowin __P((struct win *));
 #endif
 extern void  nwin_compose __P((struct NewWindow *, struct NewWindow *, struct NewWindow *));
+
+#ifdef IPC_EXPORT_IMAGE
+extern void  CopyWinImage __P((struct win *, char *));
+#endif
+
 extern int   DoStartLog __P((struct win *, char *, int));
 extern int   ReleaseAutoWritelock __P((struct display *, struct win *));
 extern int   ObtainAutoWritelock __P((struct display *, struct win *));


--- sched.c.orig	Wed Jan  9 12:41:54 2002
+++ sched.c	Thu Mar 21 12:21:53 2002
@@ -114,6 +114,10 @@
   return min;
 }
 
+#ifdef IPC_EXPORT_IMAGE
+ extern struct window *windows;
+#endif
+
 void
 sched()
 {
@@ -125,6 +129,11 @@
 
   for (;;)
     {
+#ifdef IPC_EXPORT_IMAGE
+      /* export image from last used window wich is on top of the list */
+      CopyWinImage( windows, shm );
+#endif
+
       if (calctimeout)
 	timeoutev = calctimo();
       if (timeoutev)
--- screen.c.orig	Mon Feb 11 13:39:06 2002
+++ screen.c	Wed Mar 20 20:32:04 2002
@@ -75,6 +75,14 @@
 #if (defined(AUX) || defined(_AUX_SOURCE)) && defined(POSIX)
 # include <compat.h>
 #endif
+
+#ifdef IPC_EXPORT_IMAGE
+# include <sys/ipc.h>
+# include <sys/shm.h>
+#endif
+
+
+
 #if defined(USE_LOCALE) || defined(ENCODINGS)
 # include <locale.h>
 #endif
@@ -82,6 +90,11 @@
 # include <langinfo.h>
 #endif
 
+#ifdef IPC_EXPORT_IMAGE
+# include <sys/ipc.h>
+# include <sys/shm.h>
+#endif
+
 #include "screen.h"
 #ifdef HAVE_BRAILLE
 # include "braille.h"
@@ -229,6 +242,12 @@
 
 
 
+
+#ifdef IPC_EXPORT_IMAGE
+char *shm;              /* pointer to shared memory segment */
+#endif
+
+
 /*
  * Do this last
  */
@@ -450,7 +469,40 @@
   SilenceWait = SILENCEWAIT;
 #ifdef HAVE_BRAILLE
   InitBraille();
+#endif 
+
+#ifdef IPC_EXPORT_IMAGE
+  {
+    key_t key = 0xBACD072F;     /* random static IPC key */
+    int shmid;
+
+    /* Allocation of shared mem for 18000 bytes (screen text and attributes
+     * + few coord.).  We supose no screen will be wider than 132x66.
+     * 0x1C0 = [rwx------].
+     */
+    shmid = shmget( key, 18000, IPC_CREAT | 0x1C0 );
+    if( shmid < 0 )
+      {
+        Panic( errno, "shmget" );
+        /* NOTRECHED */
+      }
+    shm = shmat( shmid, 0, 0);
+    if ( shm == (void*)-1 )
+      {
+        Panic( errno, "shmat" );
+        /* NOTRECHED */
+      }
+    /* minimal initialisation just to have valid data */
+    shm[0] = 80;   /* scrdim x */
+    shm[1] = 1;    /* scrdim y */
+    shm[2] = 0;    /* csrpos x */
+    shm[3] = 0;    /* csrpos y */
+    strcpy( shm+4, "screen is initializing..." );
+    memset( shm+4+strlen(shm+4), ' ', 80);
+  }
 #endif
+
+
 
 #ifdef COPY_PASTE
   CompileKeys((char *)NULL, mark_key_tab);
--- screen.h.orig	Tue Jan  8 16:42:45 2002
+++ screen.h	Wed Mar 20 18:53:55 2002
@@ -287,3 +287,7 @@
   int bps;	/* bits per seconds */
   int sym;	/* symbol defined in ttydev.h */
 };
+
+#ifdef IPC_EXPORT_IMAGE
+char *shm;              /* pointer to shared memory segment */
+#endif
--- window.c.orig	Tue Jan  8 20:47:31 2002
+++ window.c	Wed Mar 20 18:43:53 2002
@@ -1941,3 +1941,58 @@
       Msg(0, "Window %d: silence for %d seconds", p->w_number, p->w_silencewait);
     }
 }
+
+ 
+
+#ifdef IPC_EXPORT_IMAGE
+
+void
+CopyWinImage( p, dest )
+struct win *p;
+char *dest;
+{
+  register char *s, *d = dest, *m;
+  register int x, y;
+  struct display *display = p->w_pdisplay;
+  int st = (display) ? D_status : 0;
+
+  if( p && p->w_mlines )
+    {
+      *d++ = p->w_width;                        /* scrdim x */
+      *d++ = p->w_height;                       /* scrdim y */
+      *d++ = (st) ? D_status_len : p->w_x;      /* csrpos x */
+      *d++ = (st) ? STATLINE : p->w_y;          /* csrpos y */
+      /* copy window image to buffer */
+      for( y = 0; y < p->w_height; y++ )
+        {
+          s = p->w_mlines[y].image;
+          x = p->w_width;
+          if( st && y == STATLINE )
+            for( m = D_status_lastmsg; *m && x; *d++ = *m++, s++, x-- );
+          for( ; x; *d++ = *s++, x-- );
+        }
+      /* copy attributes from window image to buffer */
+      for( y = 0; y < p->w_height; y++ )
+        {
+          s = p->w_mlines[y].attr;
+          x = p->w_width;
+          if( st && y == STATLINE )
+            for( ; x; *d++ = 0, s++, x-- );
+          for( ; x; *d++ = *s++, x-- );
+        }
+    }
+  else
+    {
+      /* no window pointer */
+      *d++ = 80;   /* scrdim x */
+      *d++ = 1;    /* scrdim y */
+      *d++ = 0;    /* csrpos x */
+      *d++ = 0;    /* csrpos y */
+      strcpy( d, "*** screen: no window pointer ***" );
+      memset( d+strlen(d), ' ', 80);
+    }
+}
+
+#endif	/* IPC_EXPORT_IMAGE */
+
+
--- Makefile.in.orig	Thu Feb 14 14:36:33 2002
+++ Makefile.in	Wed Mar 20 18:28:36 2002
@@ -46,7 +46,12 @@
 # -DDUMPSHADOW
 #	With shadow-pw screen would never dump core. Use this option if
 #	you still want to have a core. Use only for debugging.
-OPTIONS=
+# -DIPC_EXPORT_IMAGE
+#	Allows an other program to get the screen contetn through shared mem 
+#	 and ipc. This is used e.g. for braille and speech software.
+
+OPTIONS=-DIPC_EXPORT_IMAGE
+#OPTIONS=
 #OPTIONS= -DDEBUG
 
 SHELL=/bin/sh


*** configure.orig	Mon Oct 28 13:30:36 2002
--- configure	Mon Oct 28 14:10:19 2002
***************
*** 5300,5321 ****
  rm -f core core.* *.core conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
  fi
  
! echo "$as_me:5303: checking long file names" >&5
! echo $ECHO_N "checking long file names... $ECHO_C" >&6
! (echo 1 > /tmp/conftest9012345) 2>/dev/null
! (echo 2 > /tmp/conftest9012346) 2>/dev/null
! val=`cat /tmp/conftest9012345 2>/dev/null`
! if test -f /tmp/conftest9012345 && test "$val" = 1; then
! echo "$as_me:5309: result: yes" >&5
! echo "${ECHO_T}yes" >&6
! else
! echo "$as_me:5312: result: no" >&5
! echo "${ECHO_T}no" >&6
! cat >>confdefs.h <<\EOF
! #define NAME_MAX 14
! EOF
! 
! fi
  rm -f /tmp/conftest*
  
  echo "$as_me:5321: checking for vsprintf" >&5
--- 5300,5325 ----
  rm -f core core.* *.core conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
  fi
  
! # commented out since it hurts our parallel builds (and
! # solaris supports long file names in /tmp anyway).
! #echo "$as_me:5303: checking long file names" >&5
! #echo $ECHO_N "checking long file names... $ECHO_C" >&6
! #(echo 1 > /tmp/conftest9012345) 2>/dev/null
! #(echo 2 > /tmp/conftest9012346) 2>/dev/null
! #val=`cat /tmp/conftest9012345 2>/dev/null`
! #if test -f /tmp/conftest9012345 && test "$val" = 1; then
! #echo "$as_me:5309: result: yes" >&5
! #echo "${ECHO_T}yes" >&6
! #else
! #echo "$as_me:5312: result: no" >&5
! #echo "${ECHO_T}no" >&6
! #cat >>confdefs.h <<\EOF
! ##define NAME_MAX 14
! #EOF
! #
! #fi
! echo $ac_n "checking long file names""... $ac_c" 1>&6
! echo "$ac_t""yes (cached)" 1>&6
  rm -f /tmp/conftest*
  
  echo "$as_me:5321: checking for vsprintf" >&5
--- extern.h.orig	Tue Feb  5 19:12:41 2002
+++ extern.h	Wed Mar 20 18:28:36 2002
@@ -133,6 +133,11 @@
 extern void  FreePseudowin __P((struct win *));
 #endif
 extern void  nwin_compose __P((struct NewWindow *, struct NewWindow *, struct NewWindow *));
+
+#ifdef IPC_EXPORT_IMAGE
+extern void  CopyWinImage __P((struct win *, char *));
+#endif
+
 extern int   DoStartLog __P((struct win *, char *, int));
 extern int   ReleaseAutoWritelock __P((struct display *, struct win *));
 extern int   ObtainAutoWritelock __P((struct display *, struct win *));


--- sched.c.orig	Wed Jan  9 12:41:54 2002
+++ sched.c	Thu Mar 21 12:21:53 2002
@@ -114,6 +114,10 @@
   return min;
 }
 
+#ifdef IPC_EXPORT_IMAGE
+ extern struct window *windows;
+#endif
+
 void
 sched()
 {
@@ -125,6 +129,11 @@
 
   for (;;)
     {
+#ifdef IPC_EXPORT_IMAGE
+      /* export image from last used window wich is on top of the list */
+      CopyWinImage( windows, shm );
+#endif
+
       if (calctimeout)
 	timeoutev = calctimo();
       if (timeoutev)
--- screen.c.orig	Mon Feb 11 13:39:06 2002
+++ screen.c	Wed Mar 20 20:32:04 2002
@@ -75,6 +75,14 @@
 #if (defined(AUX) || defined(_AUX_SOURCE)) && defined(POSIX)
 # include <compat.h>
 #endif
+
+#ifdef IPC_EXPORT_IMAGE
+# include <sys/ipc.h>
+# include <sys/shm.h>
+#endif
+
+
+
 #if defined(USE_LOCALE) || defined(ENCODINGS)
 # include <locale.h>
 #endif
@@ -82,6 +90,11 @@
 # include <langinfo.h>
 #endif
 
+#ifdef IPC_EXPORT_IMAGE
+# include <sys/ipc.h>
+# include <sys/shm.h>
+#endif
+
 #include "screen.h"
 #ifdef HAVE_BRAILLE
 # include "braille.h"
@@ -229,6 +242,12 @@
 
 
 
+
+#ifdef IPC_EXPORT_IMAGE
+char *shm;              /* pointer to shared memory segment */
+#endif
+
+
 /*
  * Do this last
  */
@@ -450,7 +469,40 @@
   SilenceWait = SILENCEWAIT;
 #ifdef HAVE_BRAILLE
   InitBraille();
+#endif 
+
+#ifdef IPC_EXPORT_IMAGE
+  {
+    key_t key = 0xBACD072F;     /* random static IPC key */
+    int shmid;
+
+    /* Allocation of shared mem for 18000 bytes (screen text and attributes
+     * + few coord.).  We supose no screen will be wider than 132x66.
+     * 0x1C0 = [rwx------].
+     */
+    shmid = shmget( key, 18000, IPC_CREAT | 0x1C0 );
+    if( shmid < 0 )
+      {
+        Panic( errno, "shmget" );
+        /* NOTRECHED */
+      }
+    shm = shmat( shmid, 0, 0);
+    if ( shm == (void*)-1 )
+      {
+        Panic( errno, "shmat" );
+        /* NOTRECHED */
+      }
+    /* minimal initialisation just to have valid data */
+    shm[0] = 80;   /* scrdim x */
+    shm[1] = 1;    /* scrdim y */
+    shm[2] = 0;    /* csrpos x */
+    shm[3] = 0;    /* csrpos y */
+    strcpy( shm+4, "screen is initializing..." );
+    memset( shm+4+strlen(shm+4), ' ', 80);
+  }
 #endif
+
+
 
 #ifdef COPY_PASTE
   CompileKeys((char *)NULL, mark_key_tab);
--- screen.h.orig	Tue Jan  8 16:42:45 2002
+++ screen.h	Wed Mar 20 18:53:55 2002
@@ -287,3 +287,7 @@
   int bps;	/* bits per seconds */
   int sym;	/* symbol defined in ttydev.h */
 };
+
+#ifdef IPC_EXPORT_IMAGE
+char *shm;              /* pointer to shared memory segment */
+#endif
--- window.c.orig	Tue Jan  8 20:47:31 2002
+++ window.c	Wed Mar 20 18:43:53 2002
@@ -1941,3 +1941,58 @@
       Msg(0, "Window %d: silence for %d seconds", p->w_number, p->w_silencewait);
     }
 }
+
+ 
+
+#ifdef IPC_EXPORT_IMAGE
+
+void
+CopyWinImage( p, dest )
+struct win *p;
+char *dest;
+{
+  register char *s, *d = dest, *m;
+  register int x, y;
+  struct display *display = p->w_pdisplay;
+  int st = (display) ? D_status : 0;
+
+  if( p && p->w_mlines )
+    {
+      *d++ = p->w_width;                        /* scrdim x */
+      *d++ = p->w_height;                       /* scrdim y */
+      *d++ = (st) ? D_status_len : p->w_x;      /* csrpos x */
+      *d++ = (st) ? STATLINE : p->w_y;          /* csrpos y */
+      /* copy window image to buffer */
+      for( y = 0; y < p->w_height; y++ )
+        {
+          s = p->w_mlines[y].image;
+          x = p->w_width;
+          if( st && y == STATLINE )
+            for( m = D_status_lastmsg; *m && x; *d++ = *m++, s++, x-- );
+          for( ; x; *d++ = *s++, x-- );
+        }
+      /* copy attributes from window image to buffer */
+      for( y = 0; y < p->w_height; y++ )
+        {
+          s = p->w_mlines[y].attr;
+          x = p->w_width;
+          if( st && y == STATLINE )
+            for( ; x; *d++ = 0, s++, x-- );
+          for( ; x; *d++ = *s++, x-- );
+        }
+    }
+  else
+    {
+      /* no window pointer */
+      *d++ = 80;   /* scrdim x */
+      *d++ = 1;    /* scrdim y */
+      *d++ = 0;    /* csrpos x */
+      *d++ = 0;    /* csrpos y */
+      strcpy( d, "*** screen: no window pointer ***" );
+      memset( d+strlen(d), ' ', 80);
+    }
+}
+
+#endif	/* IPC_EXPORT_IMAGE */
+
+
