###############################################################################
# libbrlapi - A library providing access to braille terminals for applications.
#
# Copyright (C) 2006-2009 by Dave Mielke <dave@mielke.cc>
#
# libbrlapi comes with ABSOLUTELY NO WARRANTY.
#
# This is free software, placed under the terms of the
# GNU Lesser General Public License, as published by the Free Software
# Foundation; either version 2.1 of the License, or (at your option) any
# later version. Please see the file LICENSE-LGPL for details.
#
# Web Page: http://mielke.cc/brltty/
#
# This software is maintained by Dave Mielke <dave@mielke.cc>.
###############################################################################

source [file join [file dirname $argv0] prologue.tcl]

proc getPackageDirectory {} {
   set rootEnd [expr {[set rootCount [llength [file split [set rootPath [file normalize /]]]]] - 1}]

   foreach pathVariable {tcl_pkgPath auto_path} {
      global $pathVariable
      if {[info exists $pathVariable]} {
         foreach directory [set $pathVariable] {
            set count [llength [set components [file split [file normalize $directory]]]]
            if {($count <= $rootEnd) || ![string equal $rootPath [eval file join [lrange $components 0 $rootEnd]]]} {
               continue
            }
            set directory [eval file join / [lrange $components $rootCount end]]

            if {[lsearch -regexp [file split $directory] {^lib(?:64)?$}] >= 0} {
               global optionValues packageName packageVersion
               return [file join "$optionValues(root)$directory" "$packageName-$packageVersion"]
            }
         }
      }
   }

   writeProgramMessage "platform-dependent packages directory not defined."
   exit 3
}

proc makeIndex {} {
   global optionValues packageDirectory packageName packageVersion packageFile
   set index [open [file join $packageDirectory "pkgIndex.tcl"] {WRONLY CREAT TRUNC}]

   set template [open [info script] {RDONLY}]
   set state 0
   while {[gets $template line] >= 0} {
      if {[regexp {^#{2,} *$} $line]} {
         incr state
      } elseif {![regexp {^#} $line]} {
         break
      }

      if {$state > 0} {
         puts $index $line
      }

      if {$state > 1} {
         break
      }
   }
   puts $index ""
   close $template; unset template

   if {[string equal [file extension $packageFile] [info sharedlibextension]]} {
      set command "load"
   } else {
      set command "source"
   }
   puts $index "package ifneeded [string totitle $packageName] $packageVersion \[list $command \[file join \$dir $packageFile\]\]"
   close $index; unset index
}

processProgramOptions optionValues {
   {root    string: "the install root on the build system"}
}

switch -exact -- [set function [nextArgument "function"]] {
   install {
      set packageName [nextArgument "package name"]
      set packageVersion [nextArgument "package version"]
      set packageFile [nextArgument "package file name"]
      noMoreArguments
      set packageDirectory [getPackageDirectory]

      if {[catch [list file mkdir $packageDirectory] response] != 0} {
         writeProgramMessage $response
         exit 4
      }

      if {[catch [list file copy -force -- $packageFile $packageDirectory] response] != 0} {
         writeProgramMessage $response
         exit 5
      }

      if {[catch [list makeIndex] response] != 0} {
         writeProgramMessage $response
         exit 6
      }
   }

   uninstall {
      set packageName [nextArgument "package name"]
      set packageVersion [nextArgument "package version"]
      noMoreArguments
      set packageDirectory [getPackageDirectory]

      if {[catch [list file delete -force -- $packageDirectory] response] != 0} {
         writeProgramMessage $response
         exit 9
      }
   }

   default {
      syntaxError "unknown function: $function"
   }
}

exit 0
